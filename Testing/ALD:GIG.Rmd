---
title: "ALD/GIG"
author: "Ayush Agarwal"
date: "24/07/2020"
output: pdf_document
---

```{r, include=FALSE}
library(Rcpp)
library(RcppArmadillo)
require(ald)
require(GIGrvg)
library(microbenchmark)
set.seed(10)
```

## ALD generation function 

**My implementation**

This implementation corresponds to Equation (2) of README. Existing sampler in `ald` package.
```{Rcpp ALD, include=FALSE}
#include "RcppArmadillo.h"
// [[Rcpp::depends(RcppArmadillo)]]
////////////////////////////////////
///// ALD function!

// [[Rcpp::export]]
arma::vec rald_mix(double n,double mu,double sigma,double p)
{
  if(n <= 0 || std::floor(n) !=n) 
    Rcpp::stop("Sample size must be a positive integer value.");
  if(sigma <= 0) 
    Rcpp::stop("sigma (scale parameter) must be a positive number.");
  if(p >= 1 || p <= 0) 
    Rcpp::stop("p must be a real number in (0,1).");
  if(abs(mu) ==R_PosInf) 
    Rcpp::stop("mu (location parameter) must be a finite real number.");
  
  double theta = (1-2*p)/(p*(1-p));
  double tau = sqrt(2/(p*(1-p)));
  
  arma::vec z = Rcpp::rexp(n,1);
  arma::vec u = arma::randn<arma::vec>(n);
  
  arma::vec r = sigma*(theta*z + tau*((arma::sqrt(z))%u));
  r = r + mu;
  return(r);
}

```

**Tests and Comparisons**

**Case1**
```{r}
n <- 1e6
mu <- 2
sigma <- 4

#check for p < 1/2
p <- 0.25
mean_exp = mu + (sigma*(1-2*p))/(p*(1-p))
var_exp = (sigma^2)*(1-2*p+2*p^2)/((p*(1-p))^2)

x <- rald_mix(n,mu,sigma,p)
y <- rALD(n,mu,sigma,p)

stopifnot(all.equal(mean_exp, mean(x), tolerance=0.01)) #mean is close to expected value
stopifnot(all.equal(var_exp, var(x)[1,1], tolerance=0.1)) #variance is close to close to expected value

stopifnot(all.equal(mean(x),mean(y),tolerance=0.01))  #both samplers agree
stopifnot(all.equal(var(y), var(x)[1,1], tolerance=0.1))

plot(density(x),col="black",main="Graph comparison")
lines(density(y),col="red",type="p",cex=0.5)
```

**Speed**
```{r}
### speed, runs a 100x faster
mbm <- microbenchmark(my=rald_mix(1e5,mu,sigma,p),old=y <- rALD(1e5,mu,sigma,p),times=1)
print(mbm)
```

**Case2**
```{r}
#check for p > 1/2
p <- 0.75
mean_exp = mu + (sigma*(1-2*p))/(p*(1-p))
var_exp = (sigma^2)*(1-2*p+2*p^2)/((p*(1-p))^2)

x <- rald_mix(n,mu,sigma,p)
y <- rALD(n,mu,sigma,p)

stopifnot(all.equal(mean_exp, mean(x), tolerance=0.01)) #mean is close to expected value
stopifnot(all.equal(var_exp, var(x)[1,1], tolerance=0.1))  #variance is close to close to expected value

stopifnot(all.equal(mean(x),mean(y),tolerance=0.01)) #both samplers agree
stopifnot(all.equal(var(y), var(x)[1,1], tolerance=0.1))

plot(density(x),col="black",main="Graph comparison")
lines(density(y),col="red",type="p",cex=0.5)
```

**Case3**
```{r}
#check for p = 1/2, eqv to double laplace
p <- 0.50
mean_exp = mu + (sigma*(1-2*p))/(p*(1-p))
var_exp = (sigma^2)*(1-2*p+2*p^2)/((p*(1-p))^2)

x <- rald_mix(n,mu,sigma,p)
y <- rALD(n,mu,sigma,p)

stopifnot(all.equal(mean_exp, mean(x), tolerance=0.01)) #mean is close to expected value
stopifnot(all.equal(var_exp, var(x)[1,1], tolerance=0.1))  #variance is close to close to expected value

stopifnot(all.equal(mean(x),mean(y),tolerance=0.01)) #both samplers agree
stopifnot(all.equal(var(y), var(x)[1,1], tolerance=0.1))

plot(density(x),col="black",main="Graph comparison")
lines(density(y),col="red",type="p",cex=0.5)
```


## GIG generation function

**My implementation**

This is my implementation of the GIG sampler, corresponding to Equation (7) in README. Existing implementation in `GIGrvg`

```{Rcpp, include=FALSE}
#include <RcppArmadillo.h>

// [[Rcpp::depends(RcppArmadillo)]]
////////////////////////////////////
///// GIG function!

double mode(double lambda,double omega)
{
  if(lambda>=1)
    return((sqrt((lambda-1)*(lambda-1)+omega*omega)+(lambda-1))/omega);

  return(omega/(sqrt((1-lambda)*(1-lambda)+omega*omega)+(1-lambda)));
}

int rgig_noshift(arma::vec*out, int n, double lambda, int check, double omega, double alpha)
{
  double xm,nc,ym,um,s,t,U,V,X;

  t = 0.5*(lambda-1);
  s = 0.25*omega;

  xm = mode(lambda,omega);
  nc = t*log(xm) - s*(xm + 1/xm);
  ym = ((lambda+1) + sqrt((lambda+1)*(lambda+1) + omega*omega))/omega;
  um = exp(0.5*(lambda+1)*log(ym) - s*(ym + 1/ym) - nc);

  for(int i=0; i<n; i++)
  {
    do{
      U = um*arma::randu<double>();
      V = arma::randu<double>();
      X = U/V;
    } while ((log(V)) > (t*log(X) - s*(X+1/X)- nc));
    (*out)(i) = (check==1) ? (alpha/X) : (alpha*X);
  }
  return(0);
}

int rgig_shift(arma::vec*out, int n, double lambda, int check, double omega, double alpha)
{
  double xm,nc,s,t,U,V,X,a,b,c,p,q,fi,fak,y1,y2,uplus,uminus;

  t = 0.5*(lambda-1);
  s = 0.25*omega;

  xm = mode(lambda,omega);
  nc = t*log(xm) - s*(xm + 1/xm);

  a = -(2*(lambda+1)/omega +xm);
  b = (2*(lambda-1)*xm/omega -1);
  c = xm;

  p = b - a*a/3;
  q = (2*a*a*a)/27 - (a*b)/3 + c;

  fi = acos(-q/(2*sqrt(-p*p*p/27)));
  fak = 2*sqrt(-p/3);
  y1 = fak*cos(fi/3) - a/3;
  y2 = fak*cos(fi/3 + (4./3.)*M_PI) - a/3;

  uplus = (y1-xm)*exp(t*log(y1) - s*(y1 + 1/y1) -nc);
  uminus =  (y2-xm)*exp(t*log(y2) - s*(y2 + 1/y2) -nc);

  for(int i=0; i<n; i++)
  {
    do{
      U = uminus + arma::randu<double>() * (uplus-uminus);
      V = arma::randu<double>();
      X = U/V + xm;
    } while ((X<=0) || ((log(V)) > (t*log(X) - s*(X+1/X)- nc)));
    (*out)(i) = (check==1) ? (alpha/X) : (alpha*X);
  }
  return(0);
}


int rgig_conc(arma::vec*out, int n, double lambda, int check, double omega, double alpha)
{
  arma::vec A(3);
  double Atot,k0,k1,k2,xm,x0,a,U,V,X,hx;

  if(lambda >=1 || omega > 1)
    Rcpp::stop("Invalid parameters.");

  xm = mode(lambda,omega);
  x0 = omega/(1-lambda);

  k0 = exp((lambda-1)*log(xm) - 0.5*omega*(xm + 1/xm));
  A(0) = k0*x0;

  if(x0 >= 2/omega)
  {
    k1 = 0;
    A(1) = 0;
    k2 = pow(x0,lambda-1);
    A(2) = k2*2*exp(-omega*x0/2)/omega;
  }

  else
  {
    k1 = exp(-omega);
    A(1) = (lambda==0) ? (k1*log(2/(omega*omega))) : ((k1/lambda)*(pow(2/omega,lambda) - pow(x0,lambda)));
    k2 = pow(2/omega,lambda-1);
    A(2) = k2*2*exp(-1)/omega;
  }

  Atot = A(0) + A(1) + A(2);

  for(int i=0; i<n; i++)
  {
    do{
      V = Atot*(arma::randu<double>());

      do{

        if(V <= A(0))
        {
          X = x0*V/A(0);
          hx = k0;
          break;
        }

        V -= A(0);
        if (V <= A(1)) {
          if (lambda == 0) {
            X = omega * exp(exp(omega)*V);
            hx = k1 / X;
          }
          else {
            X = pow(pow(x0, lambda) + (lambda / k1 * V), 1/lambda);
            hx = k1 * pow(X, lambda-1);
          }
          break;
        }

        V -= A(1);
        a = (x0 > 2/omega) ? x0 : 2/omega;
        X = -2/omega * log(exp(-omega/2 * a) - omega/(2*k2) * V);
        hx = k2 * exp(-omega/2 * X);
        break;

      } while(0);

      U = hx*(arma::randu<double>());

      if(log(U) <= (lambda-1)*log(X) - omega/2 * (X+1/X))
      {
        (*out)(i) = (check==1) ? (alpha/X) : (alpha*X);
        break;
      }
    } while(1);
  }
  return(0);
}


// [[Rcpp::export]]

arma::vec rgig_my(double n,double lambda,double a,double b)
{
  arma::vec out(n);
  int check = 0;

  if(n<=0||std::floor(n) !=n)
    Rcpp::stop("sample size 'n' must be a positive integer");

  if ( !(R_FINITE(lambda) && R_FINITE(b) && R_FINITE(a)) ||
       (b <  0. || a < 0)      ||
       (b == 0. && lambda <= 0.) ||
       (a == 0. && lambda >= 0.) )
    Rcpp::stop("Invalid Parameters");

  if(b==0)
  {
    if(lambda>0)
      return(Rcpp::rgamma(n,lambda,2/a));
    else
      return(1/Rcpp::rgamma(n,-lambda,2/a));
  }

  else if(a==0)
  {
    if(lambda>0)
      return(Rcpp::rgamma(n,lambda,2/b));
    else
      return(1/Rcpp::rgamma(n,-lambda,2/b));
  }

  else
  {

    if(lambda<0)
    {
      lambda = -lambda;
      check = 1;
    }
    double alpha = sqrt(b/a);
    double omega = sqrt(a*b);

    if(lambda > 2 || omega > 3)
    {
      //RoU shift
      rgig_shift(&out,n,lambda,check,omega,alpha);
      return(out);
    }

    if(lambda >= 1 - 2.25*a*b || omega > 0.2)
    {
      //RoU no shift
      rgig_noshift(&out,n,lambda,check,omega,alpha);
      return(out);
    }

    if(lambda>=0 && omega>0)
    {
      //log-concave
      rgig_conc(&out,n,lambda,check,omega,alpha);
      return(out);
    }

    Rcpp::stop("Invalid parameters.");
  }
  return(out);
}


```

**Tests and Comparisons**

**Case1**
```{r}
n <- 1e6
lambda = 0.5
a = 1
b = 2

x <- rgig_my(n,lambda,a,b)
y <- rgig(n,lambda,chi=b,psi=a)

stopifnot(all.equal(mean(x), mean(y), tolerance=0.01)) #mean is close to expected value
stopifnot(all.equal(var(x)[1,1], var(y), tolerance=0.1)) #variance is close to close to expected value

##plots
plot(density(x),col="black",main="Graph comparison")
lines(density(y),col="red",type="p",cex=0.5)
```

**Speed**
Speed seems a bit slow on average but that is just due to conversions when returning back to R, in my use it'll be an internal function and hence the issue is to be neglected.
```{r}
## speed comparison
mbm <- microbenchmark(my=rgig_my(n,lambda,a,b),his=rgig(n,lambda,chi=b,psi=a),times=5)
print(mbm)
```

**Case2**
```{r}
lambda = -0.50
a = 3
b = 5

x <- rgig_my(n,lambda,a,b)
y <- rgig(n,lambda,chi=b,psi=a)

stopifnot(all.equal(mean(x), mean(y), tolerance=0.01)) #mean is close to expected value
stopifnot(all.equal(var(x)[1,1], var(y), tolerance=0.1)) #variance is close to close to expected value

##plots
plot(density(x),col="black",main="Graph comparison")
lines(density(y),col="red",type="p",cex=0.5)
```

**Case3**
```{r}
lambda = -1
a = 0.25
b = 0.50

x <- rgig_my(n,lambda,a,b)
y <- rgig(n,lambda,chi=b,psi=a)

stopifnot(all.equal(mean(x), mean(y), tolerance=0.01)) #mean is close to expected value
stopifnot(all.equal(var(x)[1,1], var(y), tolerance=0.1)) #variance is close to close to expected value

##plots
plot(density(x),col="black",main="Graph comparison")
lines(density(y),col="red",type="p",cex=0.5)
```


